c      ::= import "c/types.ic"
cmath  ::= import "c/math.ic"
stdlib ::= import "c/stdlib.ic"

#{export} Abs ::= cmath.fabsf
#{export} Abs ::= cmath.fabs
#{export} Abs ::= stdlib.abs
// TODO: In C/C++, `long` and `long long` are different types even if they have 
// the same bit representations. Icarus only has one representation and so it is
// possible that the definitions of the C library functions `labs` and `llabs`
// have indistinguishable types in Icarus. We do not currently have a mechanism
// that allows us to detect this and omit one conditionally, because
// overload-sets are not entirely first-class citizens yet.
#{export} Abs ::= stdlib.labs
// #{export} Abs ::= stdlib.llabs

#{export} (%) ::= cmath.fmodf
#{export} (%) ::= cmath.fmod

// TODO: Support compile-time rounding enumerator tag.
#{export} Floor     ::= cmath.floorf
#{export} Floor     ::= cmath.floor
#{export} Ceiling   ::= cmath.ceilf
#{export} Ceiling   ::= cmath.ceil
#{export} Truncate  ::= cmath.truncf
#{export} Truncate  ::= cmath.trunc

#{export} Divide ::= (numerator: c.float, denominator: c.float)  -> (c.int, c.float) {
  quotient: c.int
  remainder := cmath.remquof(numerator, denominator, &quotient)
  return quotient, remainder
}

#{export} Divide ::= (numerator: c.double, denominator: c.double)  -> (c.int, c.double) {
  quotient: c.int
  remainder := cmath.remquo(numerator, denominator, &quotient)
  return quotient, remainder
}

#{export} SplitIntegral ::= (x: c.float) -> (c.float, c.float) {
  ipart: c.float
  fpart: c.float
  cmath.modff(x, &ipart)
  return ipart, fpart
}

#{export} SplitIntegral ::= (x: c.double) -> (c.double, c.double) {
  ipart: c.double
  fpart: c.double
  cmath.modf(x, &ipart)
  return ipart, fpart
}

#{export} SquareRoot ::= cmath.sqrtf
#{export} SquareRoot ::= cmath.sqrt
#{export} CubeRoot   ::= cmath.cbrtf
#{export} CubeRoot   ::= cmath.cbrt
#{export} Exp        ::= cmath.expf
#{export} Exp        ::= cmath.exp
#{export} Log        ::= cmath.logf
#{export} Log        ::= cmath.log
#{export} Pow        ::= cmath.powf
#{export} Pow        ::= cmath.pow

#{export} FusedMultiplyAdd ::= cmath.fmaf
#{export} FusedMultiplyAdd ::= cmath.fma

#{export} Erf ::= cmath.erff
#{export} Erf ::= cmath.erf

#{export} Gamma ::= cmath.tgammaf
#{export} Gamma ::= cmath.tgamma
