#ifndef ICARUS_IR_MODULE_H
#define ICARUS_IR_MODULE_H

#include <deque>
#include <memory>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "absl/container/node_hash_map.h"
#include "base/debug.h"
#include "base/iterator.h"
#include "ir/byte_code/byte_code.h"
#include "ir/subroutine.h"
#include "ir/value/fn.h"
#include "ir/value/module_id.h"
#include "ir/value/scope.h"
#include "type/function.h"
#include "type/type.h"

namespace ir {

struct NativeFunctionInformation {
  type::Function const *type() const {
    return &fn.type()->as<type::Function>();
  }
  Subroutine fn;
  ByteCode byte_code;
};

// Holds all information about generated IR.
struct Module {
  explicit Module(ModuleId m) : module_id_(m) {}

  template <auto EmitByteCode>
  void WriteByteCode(Scope s) {
    auto iter = scope_data_.find(s);
    ASSERT(iter != scope_data_.end());
    auto &[byte_code, data] = iter->second;
    byte_code = EmitByteCode(*s);
    data->byte_code = &byte_code;
  }

  template <auto EmitByteCode>
  void WriteByteCode(Fn f) {
    ASSERT(f.module() == module_id_);
    auto &info     = functions_[f.local().value()];
    info.byte_code = EmitByteCode(info.fn);
  }

  NativeFunctionInformation const &function(LocalFnId id) const {
    ASSERT(id.value() < functions_.size());
    return functions_[id.value()];
  }

  Fn InsertFunction(ir::Subroutine fn, ir::ByteCode byte_code);
  Scope InsertScope(type::Scope const *scope_type);

  // Inject special member functions. These functions allocate space for, but do
  // not actually compile the functions.
  std::pair<Fn, bool> InsertInit(type::Type t);
  std::pair<Fn, bool> InsertDestroy(type::Type t);
  std::pair<Fn, bool> InsertMoveAssign(type::Type to, type::Type from);
  std::pair<Fn, bool> InsertCopyAssign(type::Type to, type::Type from);
  std::pair<Fn, bool> InsertMoveInit(type::Type to, type::Type from);
  std::pair<Fn, bool> InsertCopyInit(type::Type to, type::Type from);

  auto functions() const {
    return base::iterator_range(functions_.begin(), functions_.end());
  }
  auto scopes() const {
    return base::iterator_range(scopes_.begin(), scopes_.end());
  }

 private:
  LocalFnId InsertFunctionIndex(type::Function const *fn_type);

  // All functions in this module, whether they're directly compiled or
  // generated by a generic. We use a std::deque because we rarely
  // iterate through them, but want pointer-stability.
  std::deque<NativeFunctionInformation> functions_;
  std::deque<Subroutine> scopes_;

  absl::node_hash_map<Scope, std::pair<ByteCode, std::unique_ptr<Scope::Data>>>
      scope_data_;

  ModuleId module_id_;
  absl::flat_hash_map<type::Type, LocalFnId> init_, destroy_;
  absl::flat_hash_map<std::pair<type::Type, type::Type>, LocalFnId>
      copy_assign_, move_assign_, copy_init_, move_init_;
};

}  // namespace ir

#endif  // ICARUS_IR_MODULE_H
