#ifndef ICARUS_IR_MODULE_H
#define ICARUS_IR_MODULE_H

#include <forward_list>
#include <memory>
#include <utility>

#include "absl/container/flat_hash_map.h"
#include "base/debug.h"
#include "base/iterator.h"
#include "ir/byte_code/byte_code.h"
#include "ir/compiled_fn.h"
#include "ir/value/native_fn.h"
#include "type/function.h"
#include "type/type.h"

namespace ir {

// Holds all information about generated IR.
struct Module {
  template <auto EmitByteCode>
  void WriteByteCode(NativeFn f) {
    auto iter = fn_data_.find(f);
    ASSERT(iter != fn_data_.end());
    auto &[byte_code, data] = iter->second;
    ASSERT(byte_code.size() == 0u);
    byte_code = EmitByteCode(*f);
    ASSERT(byte_code.size() != 0u);
    data->byte_code = byte_code.begin();
  }

  NativeFn InsertFunction(type::Function const *fn_type);

  // Inject special member functions. These functions allocate space for, but do
  // not actually compile the functions.
  std::pair<NativeFn, bool> InsertInit(type::Type t);
  std::pair<NativeFn, bool> InsertDestroy(type::Type t);
  std::pair<NativeFn, bool> InsertMoveAssign(type::Type to, type::Type from);
  std::pair<NativeFn, bool> InsertCopyAssign(type::Type to, type::Type from);
  std::pair<NativeFn, bool> InsertMoveInit(type::Type to, type::Type from);
  std::pair<NativeFn, bool> InsertCopyInit(type::Type to, type::Type from);

  auto functions() const {
    return base::iterator_range(fns_.begin(), fns_.end());
  }

 private:
  // All functions in this module, whether they're directly compiled or
  // generated by a generic. We use a std::forward_list because we rarely
  // iterate through them, but want pointer-stability.
  std::forward_list<CompiledFn> fns_;

  // Holds the byte code for each function defined in this context. The
  // `ByteCode` object itself, once inserted into the map, should never be
  // modified. Iterators may reference into it. As `byte_code_` is further
  // modified, the values may be moved, but iterators will remain valid.
  absl::flat_hash_map<NativeFn,
                      std::pair<ByteCode, std::unique_ptr<NativeFn::Data>>>
      fn_data_;

   absl::flat_hash_map<type::Type, NativeFn> init_, destroy_;
   absl::flat_hash_map<std::pair<type::Type, type::Type>, NativeFn>
       copy_assign_, move_assign_, copy_init_, move_init_;
};

}  // namespace ir

#endif  // ICARUS_IR_MODULE_H
