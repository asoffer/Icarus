#{export}
for ::= scope [c] (low: i64, high: i64) {
  i := low
  while (i < high) {
    i >> c.do
    i += 1
  }
}

// TODO: Accept unsigned as well
#{export}
repeat ::= scope [c] (count: i64) {
  for (0, count) do [n: i64] { >> c.do }
}

#{export}
forever ::= scope [c] () {
  while (true) { >> c.do }
}

#{export}
exchange ::= (x: *~`T, y: T) -> T {
  result: T
  result = @x
  @x = y
  return result
}

#{export}
exchange ::= (x: *~`T, y: *T, z: T) -> T {
  result: T
  result = @x
  @x = @y
  @y = z
  return result
}

max_impl ::= (t :: type) -> integer {
  if (t == i8) { return 127 }
  if (t == i16) { return 32767 }
  if (t == i32) { return 2147483647 }
  if (t == i64) { return 9223372036854775807 }
  // TODO: This should emit an error message. Or better yet we should constrain 
  // `t` to only accept supported types.
  builtin.abort()
}

#{export}
max ::= (t :: type) => max_impl(t) as t
