IcarusInfo = provider(
    "Information needed to compile and link an Icarus binary",
    fields = {},
)

def _tooling_transition_impl(settings, attr):
    return {
        "//command_line_option:compilation_mode": "opt",
        "//command_line_option:cpu": "clang",
    }

_tooling_transition = transition(
    implementation = _tooling_transition_impl,
    inputs = [
        "//command_line_option:compilation_mode",
        "//command_line_option:cpu", 
    ],
    outputs = [
        "//command_line_option:compilation_mode",
        "//command_line_option:cpu", 
    ],
)

def _module_mapping(deps):
    """
    Given a list of dependencies `deps`, returns a map keyed on source file
    names where the associated value is a pair consisting of:
    * The unique label associtaed to this module.
    * A `depset` consisting of the precompiled modules generated by each
      dependency.
    """
    return {
        target[IcarusInfo].sources[0]: struct(
            label = target.label,
            pcms = target[DefaultInfo].files
        )
        for target in deps
    }


def _module_map_file(ctx, mapping):
    # TODO: Change the formatting so that we do not restrict substrings in file
    # names or labels.
    module_map = ctx.actions.declare_file(ctx.label.name + ".module_map")
    ctx.actions.write(
        output = module_map,
        content = '\n'.join([
            "{file}::{label}::{icm}".format(
                file = src.files.to_list()[0].path, 
                label = icm[0],
                icm = icm[1].short_path)
            for (src, icm) in mapping.items()
        ])
    )
    return module_map


def _ic_binary_impl(ctx):
    target_deps = ctx.attr.deps + getattr(ctx.attr, "_implicit_deps", [])
    module_map = _module_mapping(target_deps)

    outputs = []
    for src in ctx.attr.srcs:
        src_file = src.files.to_list()[0]
        output = ctx.actions.declare_file("{label}-{file}.icm".format(
            label = ctx.label.name,
            file = src_file.basename[:-(1 + len(src_file.extension))]
        ))
        module_map_file = _module_map_file(ctx, module_map)

        ctx.actions.run(
            inputs = depset(
                         [module_map_file] + 
                         [icm[1] for (src, icm) in module_map.items()],
                         transitive = [src.files for src in ctx.attr.srcs],
                     ),
            outputs = [output],
            arguments = [
                "--source={}".format(src_file.path),
                "--module_identifier={}".format(str(ctx.label)),
                "--output={}".format(output.path),
            ],
            progress_message = "Compiling {}".format(ctx.label.name),
            executable = ctx.attr._compile[0][DefaultInfo].files_to_run.executable,
        )

        outputs.append(output)

    return [
        IcarusInfo(
),
        DefaultInfo(
            files = depset(outputs),
        ),
    ]



ic_binary = rule(
    implementation = _ic_binary_impl,
    attrs = {
        "srcs": attr.label_list(allow_files = [".ic"]),
        "deps": attr.label_list(providers = [IcarusInfo]),
        "_implicit_deps": attr.label_list(default = []), # [Label("//toolchain/stdlib")]),
        "_compile": attr.label(
            default = Label("//toolchain:compile"),
            allow_single_file = True,
            executable = True,
            cfg = _tooling_transition,
        ),
        "_allowlist_function_transition": attr.label(
            default = "@bazel_tools//tools/allowlists/function_transition_allowlist"
        ),
    },
)

