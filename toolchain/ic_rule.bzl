IcarusInfo = provider(
    "Information needed to compile and link an Icarus binary",
    fields = ["source"],
)

def _tooling_transition_impl(settings, attr):
    return {
#         "//command_line_option:compilation_mode": "opt",
#         "//command_line_option:cpu": "clang",
    }

_tooling_transition = transition(
    implementation = _tooling_transition_impl,
    inputs = [
        "//command_line_option:compilation_mode",
        "//command_line_option:cpu", 
    ],
    outputs = [
        "//command_line_option:compilation_mode",
        "//command_line_option:cpu", 
    ],
)

def _module_mapping(deps):
    """
    Given a list of dependencies `deps`, returns a map keyed on source file
    names where the associated value is a pair consisting of:
    * The unique label associated to this module.
    * A `depset` consisting of the precompiled modules generated by each
      dependency.
    """
    return {
        target[IcarusInfo].source: struct(
            label = target.label,
            icms = target[DefaultInfo].files
        )
        for target in deps
    }


def _dotted_path(label, icm):
    package = label.package
    if package.startswith("@"):
        package = package[1:]
    if package.startswith("//"):
        package = package[2:]
    if package.startswith("toolchain/stdlib"):
        package = "std" + package[len("toolchain/stdlib"):]
        package.replace("/", ".")
    return "{}.{}".format(package, label.name)


def _module_map_file(ctx, mapping):
# TODO: Change the formatting so that we do not restrict substrings in file
#names or labels.
    module_map = ctx.actions.declare_file(ctx.label.name + ".icmod")
    ctx.actions.write(
        output = module_map,
        content = '\n'.join([
            "{id}\n{name}\n{icm}".format(
                id = icm.label, 
                name = _dotted_path(icm.label, icm),
                icm = icm.icms.to_list()[0].path)
            for (src, icm) in mapping.items()
        ])
    )
    return module_map


def _compile(ctx, icm_file, module_map):
    module_map_file = _module_map_file(ctx, module_map)

    if len(ctx.attr.srcs) != 1:
        fail("library rules must have exactly one file in 'srcs'.")
    src = ctx.attr.srcs[0]

    src_file = src.files.to_list()[0]

    ctx.actions.run(
        inputs = depset(
                     [module_map_file],
                     transitive = [src.files for src in ctx.attr.srcs] +
                                  [icm.icms for (src, icm) in module_map.items()]
                 ),
        outputs = [icm_file],
        arguments = [
            "--source={}".format(src_file.path),
            "--module_identifier={}".format(str(ctx.label)),
            "--output={}".format(icm_file.path),
            "--module_map_file={}".format(module_map_file.path),
        ],
        progress_message = "Compiling {}".format(ctx.label.name),
        executable = ctx.attr._compile[0][DefaultInfo].files_to_run.executable,
    )
 

def _ic_binary_impl(ctx):
    target_deps = ctx.attr.deps
    module_map = _module_mapping(target_deps)
    module_map_file = _module_map_file(ctx, module_map)

    icm_file = ctx.actions.declare_file("{label}.icm".format(
        label = ctx.label.name
    ))

    _compile(ctx, icm_file, module_map)
    runfiles = ctx.runfiles(files = [icm_file])

    executable_path = "{name}%/{name}".format(name = ctx.label.name)
    executable = ctx.actions.declare_file(executable_path)

    runfiles = ctx.runfiles(files = [icm_file, ctx.executable._run_bytecode])
    ctx.actions.write(
        output = executable,
        is_executable = True,
        content = """
        {executable} --input={icm}
        """.format(
            executable = ctx.executable._run_bytecode.short_path,
            icm = icm_file.short_path,
        )
    )

    return [
        IcarusInfo(
            source = ctx.attr.srcs[0].files.to_list()[0]),
        DefaultInfo(
            files = depset([icm_file, module_map_file]),
            executable = executable,
            runfiles = runfiles,
        ),
    ]


ic_binary = rule(
    implementation = _ic_binary_impl,
    exec_groups = {
        "run_bytecode": exec_group(copy_from_rule = True),
    },
    attrs = {
        "srcs": attr.label_list(allow_files = [".ic"]),
        "deps": attr.label_list(providers = [IcarusInfo]),
        "_compile": attr.label(
            default = Label("//toolchain:compile"),
            allow_single_file = True,
            executable = True,
            cfg = _tooling_transition,
        ),
        "_run_bytecode": attr.label(
            default = Label("//toolchain:run_bytecode"),
            allow_single_file = True,
            executable = True,
            cfg = _tooling_transition,
        ),
        "_allowlist_function_transition": attr.label(
            default = "@bazel_tools//tools/allowlists/function_transition_allowlist"
        ),
    },
    executable = True,
)


def _ic_library_impl(ctx):
    target_deps = ctx.attr.deps
    module_map = _module_mapping(target_deps)

    icm_file = ctx.actions.declare_file("{label}.icm".format(
        label = ctx.label.name
    ))

    _compile(ctx, icm_file, module_map)
    runfiles = ctx.runfiles(files = [icm_file])

    return [
        IcarusInfo(source = ctx.attr.srcs[0].files.to_list()[0]),
        DefaultInfo(
            files = depset([icm_file]),
            runfiles = runfiles,
        ),
    ]


ic_library = rule(
    implementation = _ic_library_impl,
    exec_groups = {
        "run_bytecode": exec_group(copy_from_rule = True),
    },
    attrs = {
        "srcs": attr.label_list(allow_files = [".ic"]),
        "deps": attr.label_list(providers = [IcarusInfo]),
        "_compile": attr.label(
            default = Label("//toolchain:compile"),
            allow_single_file = True,
            executable = True,
            cfg = _tooling_transition,
        ),
        "_run_bytecode": attr.label(
            default = Label("//toolchain:run_bytecode"),
            allow_single_file = True,
            executable = True,
            cfg = _tooling_transition,
        ),
        "_allowlist_function_transition": attr.label(
            default = "@bazel_tools//tools/allowlists/function_transition_allowlist"
        ),
    },
)
