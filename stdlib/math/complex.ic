-- ::= import "core.ic"

#{export}
complex ::= struct {
  #{export} real: f64
  #{export} imag: f64
}

#{export}
(+) ::= (lhs: complex, rhs: complex) -> complex {
  return complex.{
    real = lhs.real + rhs.real
    imag = lhs.imag + rhs.imag
  }
}

#{export}
(-) ::= (lhs: complex, rhs: complex) -> complex {
  return complex.{
    real = lhs.real - rhs.real
    imag = lhs.imag - rhs.imag
  }
}

#{export}
(*) ::= (lhs: complex, rhs: complex) -> complex {
  return complex.{
    real = lhs.real * rhs.real - lhs.imag * rhs.imag
    imag = lhs.real * rhs.imag + lhs.imag * rhs.real
  }
}

#{export}
(+=) ::= (lhs: *complex, rhs: complex) -> () {
   lhs.real += rhs.real
   lhs.imag += rhs.imag
}

#{export}
(-=) ::= (lhs: *complex, rhs: complex) -> () {
   lhs.real -= rhs.real
   lhs.imag -= rhs.imag
}

#{export}
(*=) ::= (lhs: *complex, rhs: complex) -> () {
  (lhs.real, lhs.imag) = (
      lhs.real * rhs.real - lhs.imag * rhs.imag,
      lhs.real * rhs.imag + lhs.imag * rhs.real
  )
}

#{export}
squared_norm ::= (x: complex) -> f64 {
  return x.real * x.real + x.imag * x.imag
}

#{export}
(^)::= (x: complex, n: i64) -> complex {
  if (n == 0) {
    return complex.{ real = 1.0 \\ imag = 0.0 }
  } else if (n < 0) {
    sn := x'squared_norm
    return complex.{ real = x.real / sn \\ imag = -x.imag / sn }
  } else if (n == 1) {
    return x
  } else if (n % 2 == 0) {
    return (x * x) ^ (n / 2)
  } else {
    return x * (x * x) ^ (n / 2)
  }
}
