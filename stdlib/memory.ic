core ::= import "core.ic"

// TODO: This should get moved to cstdlib.ic
memcpy ::= foreign("memcpy", ([*]byte, [*]byte, u64) -> [*]byte)

#{export}
allocate ::= (T :: type) -> *T {
  // TODO: This should get moved to cstdlib.ic
  malloc ::= foreign("malloc", u64 -> *T)
  return malloc(T'bytes)
}

#{export}
allocate ::= (T :: type, l: u64) -> []T {
  // TODO: This should get moved to cstdlib.ic
  malloc ::= foreign("malloc", u64 -> [*]T)
  return slice(malloc(T'bytes * l), l)
}

#{export}
// TODO: Accept either a pointer or a buffer pointer.
deallocate ::= (ptr: ~`T) -> () {
  // TODO: This should get moved to cstdlib.ic
  free ::= foreign("free", T -> ())
  free(ptr)
}

#{export}
reverse_destroy_buffer ::= (ptr: ~[*]`T, count: u64) -> () {
  p := ptr + count
  core.repeat (count as i64) do {
    p -= 1
    destroy p
  }
}

#{export}
clone ::= (m: []byte) => expand(m, m.length)

#{export}
expand ::= (m: []byte, new_size: u64) -> []byte {
  buffer := allocate(byte, new_size)
  memcpy(buffer.data, m.data, m.length)
  return buffer
}

#{export}
fill ::= (m: []byte, value: u8) -> () {
  // TODO: This should get moved to cstdlib.ic
  memset ::= foreign("memset", ([*]char, i32, u64) -> [*]char)
  memset(m.data, value as i32, m.length)
}

#{export}
Copy ::= (from: []byte, to: []byte) -> () {
  memcpy(to.data, from.data, to.length)
}

// TODO: If we don't require length to be a multiple of alignment, we need to account for that here.
#{export}
to_raw ::= (s: ~[]`T) => slice(s.data as [*]byte, s.length * T'bytes)
