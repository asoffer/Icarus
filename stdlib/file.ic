c      ::= import "c/stdio.ic"
ctypes ::= import "c/types.ic"
errno  ::= import "errno.ic"
memory ::= import "memory.ic"

#{export}
File ::= struct {
  #{export} _handle: *c.File
}


#{export}
make ::= (f: *c.File) -> File {
  return File.{ _handle = f }
}

#{export}
CFileHandle ::= (f: File) => f._handle

#{export}
With ::= scope [ctx] (name: []char) {
  f: File
  f._handle = c.fopen(name.data, "r".data)
  e := errno.get()
  if (e == errno.error.SUCCESS) {
    f >> ctx.open
    c.fclose(f._handle)
  } else {
    #{const} if (ctx'has_block("error")) {
      e >> ctx.error
    }
  }
}

#{export}
read_to ::= (f: File, T :: type) -> T {
  result: T
  CHUNK_SIZE ::= 1024
  num_read := CHUNK_SIZE
  buffer: [CHUNK_SIZE; char]
  while (num_read == CHUNK_SIZE) {
    num_read = c.fread(&buffer[0], char'bytes, CHUNK_SIZE, f._handle)
    result'append(slice(&buffer[0], num_read))
  }
  return result
}

next_line ::= (handle: *c.File, line: *[]char) -> bool {
  data: [*]char
  alloc_size: ctypes.size_t
  length := c.getline(&data, &alloc_size, handle)
  if (length >= 0) {
    @line = slice(data, length as u64)
  }
  return length > 0
}

#{export}
Lines ::= scope [ctx] (f: File) {
  line := slice(null as [*]char, 0)
  while (next_line(f'CFileHandle, &line)) {
    line >> ctx.each
  }
  // TODO: Deallocate `line.data`.
}
