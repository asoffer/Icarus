c      ::= import "c/stdio.ic"
core   ::= import "core.ic"
errno  ::= import "errno.ic"
memory ::= import "memory.ic"

#{export}
File ::= struct {
  #{export} _handle: *c.File
}


#{export}
make ::= (f: *c.File) -> File {
  return File.{ _handle = f }
}


#{export}
CFileHandle ::= (f: File) => f._handle

#{export}
With ::= scope [ctx] (name: []char) {
  f: File
  f._handle = c.fopen(name.data, "r".data)
  e := errno.get()
  if (e == errno.error.SUCCESS) {
    @f >> ctx.open
    c.fclose(f._handle)
    return
  }

  e >> ctx.error
}

#{export}
read_to ::= (f: File, T :: type) -> T {
  result: T
  CHUNK_SIZE ::= 1024
  num_read := CHUNK_SIZE
  buffer: [CHUNK_SIZE; char]
  core.while (num_read == CHUNK_SIZE) do {
    num_read = c.fread(&buffer[0], char'bytes, CHUNK_SIZE, f._handle)
    result'append(slice(&buffer[0], num_read))
  }
  return result
}

LinesState ::= struct {
  handle: *c.File
  line: [*]char
  bufsize: u64
  line_length: i64

  (destroy) ::= (self: *LinesState) -> () {
    memory.deallocate(self.line)
  }
}

next_line ::= (handle: *c.File, line: *[]char) -> bool {
  data: [*]char
  alloc_size: c.size_t
  length := c.getline(&data, &alloc_size, handle)
  @line = slice(data, length as u64)
  return length > 0
}

#{export}
Lines ::= scope [ctx] (f: File) {
  line: []char
  while (next_line(f'CFileHandle, line)) {
    line >> ctx.each
    memory.deallocate(line.data)
  }
}
