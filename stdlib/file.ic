core   ::= import "core.ic"
errno  ::= import "errno.ic"
cstdio ::= import "cstdio.ic"

#{export}
File ::= struct {
  #{export}
  make ::= (f: *cstdio.File) -> File {
    return File.{ _handle = f }
  }

  #{export} _handle: *cstdio.File
}

#{export}
CFileHandle ::= (f: File) => f._handle

#{export}
With ::= scope(File) {
  enter ::= jump [f: *File] (name: char[]) {
    f._handle = cstdio.fopen(name.data, "r".data)
    e := errno.get()
    goto e == errno.error.SUCCESS, open(@f), error(e) | done()
  }

  open ::= block {
    before ::= (f: File) => f
    after ::= jump [f: *File] () {
      cstdio.fclose(f._handle)
      goto done()
    }
  }

  error ::= block {
    before ::= (e: errno.error) => e
    after ::= jump [f: *File] () { goto done() }
  }

  exit ::= () -> () {}
}

#{export}
read_to ::= (f: File, T :: type) -> T {
  result: T
  CHUNK_SIZE ::= 10 as u64
  num_read := CHUNK_SIZE
  buffer: [CHUNK_SIZE; char]
  core.while (num_read == CHUNK_SIZE) do {
    num_read = cstdio.fread(&buffer[0], char'bytes, CHUNK_SIZE, f._handle)
    result'append(slice(&buffer[0], num_read))
  }
  return result
}
