memory ::= import "memory.ic"

#{export}
string ::= struct {
  _data:     [*]char
  _length:   u64
  _capacity: u64

  (move) ::= (from: *string) -> string {
    // TODO: use core.exchange here when the cross-module generics bug is fixed.
    result := string.{
      _data     = from._data
      _length   = from._length
      _capacity = from._capacity
    }
    from._data = null
    from._length = 0
    from._capacity = 0
    return result
  }

  (move) ::= (to: *string, from: *string) -> () {
    (to._data,     from._data)     = (from._data,     null)
    (to._length,   from._length)   = (from._length,   0)
    (to._capacity, from._capacity) = (from._capacity, 0)
  }

  (copy) ::= (from: *string) -> string {
    return string.{
      _data     = memory.clone(from'raw_null_terminated_view).data
      _length   = from._length
      _capacity = from._capacity
    }
  }

  (copy) ::= (to: *string, from: *string) -> () {
    memory.deallocate(to._data)
    to._length   = from._length
    to._capacity = from._capacity
    to._data     = memory.clone(to'raw_null_terminated_view).data
  }

  (destroy) ::= (self: *string) -> () { memory.deallocate(self._data) }
}

// Resizes the buffer, copying the string data to the new buffer, excluding the
// null terminator. Assumes `new_capacity` is at least as large as`s._capacity`.
resize_buffer ::= (s: *string, new_capacity: u64) -> () {
  buffer := memory.expand(s'raw_null_terminated_view, new_capacity + 1)
  memory.deallocate(s._data)
  s._data = buffer.data
  s._capacity = new_capacity
}

// TODO: These functions should be defined inside `string`
#{export}
make ::= (fill: char, len: u64) -> string {
  buffer := memory.allocate(char, len + 1)
  memory.fill(buffer, fill as u8)
  buffer[len] = init !'\0'
  return string.{
    _data     = buffer.data
    _length   = len
    _capacity = len
  }
}

#{export}
make ::= (s: []char) -> string {
  raw := s'memory.to_raw
  raw = builtin.slice(raw.data, raw.length + 1)
  return string.{
    _data     = memory.clone(raw).data
    _length   = s.length
    _capacity = s.length
  }
}

#{export}
make ::= (capacity: u64) -> string {
  buffer := memory.allocate(char, capacity + 1)
  buffer[0] = init !'\0'
  return string.{
    _data     = buffer.data
    _length   = 0
    _capacity = capacity
  }
}

#{export}
length ::= (s: *string) => s._length

#{export}
is_empty ::= (s: *string) => s._length == 0

#{export}
append ::= (s: *string, character: char) -> () {
  if (s._capacity == 0) {
    resize_buffer(s, 1)
  } else if (s._capacity == s._length) {
    resize_buffer(s, s._capacity * 2)
  }
  s._data[s._length] = init character
  s._length += 1
  s._data[s._length] = init !'\0'
}

#{export}
append ::= (s: *string, char_slice: []char) -> () {
  if (s._length + char_slice.length > s._capacity) {
    resize_buffer(s, s._length + char_slice.length)
  }

  if (char_slice.length > 0) {
    len := char_slice.length + 1
    memory.Copy(from = builtin.slice(char_slice.data, len),
                to   = builtin.slice(s'at(s._length), len))
    s._length += char_slice.length
  }
}

#{export}
append ::= (s: *string, from: *string) -> () {
  s'append(from'view)
}

#{export}
Print ::= (s: *string) -> () {
  printf ::= builtin.foreign("printf", ([*]char, [*]char) -> i32)
  if (not s'is_empty) { printf("%s".data, s._data) }
}

#{export}
at ::= (s: *string, n: u64) => &s._data[n]

#{export}
__index__ ::= (s: *string, n: u64) => s._data[n]

// TODO: The call to `at` here should be allowed because it couldn't possibly match itself.
#{export}
at ::= (s: *string, lo: u64, hi: u64) => builtin.slice(&s._data[lo], hi - lo)

#{export}
view ::= (s: *string) => builtin.slice(s'at(0), s._length)

raw_null_terminated_view ::= (s: *string) => builtin.slice(s'at(0), s._length + 1)
