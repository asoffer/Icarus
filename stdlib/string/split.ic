match ::= import "string/match.ic"
strip ::= import "string/strip.ic"

#{export}
SplitAt ::= (s: []char, n: u64) -> ([]char, []char) {
  return slice(s.data, n), slice(s.data + n, s.length - n)
}

#{export}
SplitFirst ::= (s: []char, c: char) -> ([]char, []char) {
  n := match.Find(s, c) - s.data
  (first, rest) := SplitAt(s, n as u64)
  return first, strip.WithoutPrefix(rest, 1)
}

#{export}
SplitFirst ::= (haystack: []char, needle: []char) -> ([]char, []char) {
  n := match.Find(haystack, needle) - haystack.data
  (first, rest) := SplitAt(haystack, n as u64)
  return first, strip.WithoutPrefix(rest, needle.length)
}

#{export}
Split ::= scope [ctx] (s: []char, c: char) {
  while (s.length != 0) {
    n := match.Find(s, c) - s.data
    slice(s.data, n as u64) >> ctx.do
    s = strip.WithoutPrefix(s, (n + 1) as u64)
  }
}

// TODO: When overloads are supported, rename to Split
#{export}
Split2 ::= scope [ctx] (haystack: []char, needle: []char) {
  while (haystack.length != 0) {
    n := match.Find(haystack, needle) - haystack.data
    slice(haystack.data, n as u64) >> ctx.do
    haystack = strip.WithoutPrefix(haystack, n as u64 + needle.length)
  }
}
