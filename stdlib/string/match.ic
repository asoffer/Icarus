-- ::= import "core.ic"

#{export}
Equals ::= (a: []char, b: []char) -> bool {
  if (a.length != b.length) then { return false }
  for (0, a.length as i64) do [idx: i64] {
    if (a[idx] != b[idx]) then { return false }
  }
  return true
}

#{export}
Find ::= (s: []char, ch: char) -> [*]char {
  ptr := s.data
  end := ptr + s.length
  while (ptr != end and @ptr != ch) do { ptr += 1 }
  return ptr
}

// TODO: Use something better than brute force here.
#{export}
Find ::= (s: []char, needle: []char) -> [*]char {
  if (needle.length == 1) then { return Find(s, needle[0]) }
  ptr := s.data
  end := ptr + s.length
  if (needle.length == 0) then { return ptr }
  if (needle.length > s.length) then { return end }
  stop := end - needle.length
  while (ptr != stop) do {
    if (Equals(slice(ptr, needle.length), needle)) then { return ptr }
    ptr += 1
  }
  return end
}

#{export}
StartsWith ::= (s: []char, prefix: []char) -> bool {
  s_len := s.length as i64
  p_len := prefix.length as i64
  if (p_len > s_len) then { return false }
  for (0, p_len) do [idx: i64] {
    if (s[idx] != prefix[idx]) then { return false }
  }
  return true
}

#{export}
EndsWith ::= (s: []char, prefix: []char) -> bool {
  s_len := s.length as i64
  p_len := prefix.length as i64
  if (p_len > s_len) then { return false }
  for (1, p_len + 1) do [idx: i64] {
    if (s[s_len - idx] != prefix[p_len - idx]) then {
      return false
    }
  }
  return true
}
