-- ::= import "core.ic"
io ::= import "io.ic"

double ::= (n: i64) => 2 * n

vec ::= (T: type,
         resize_by ::= double) => struct {
  _size: int
  _data: [--; T]
}

#{export}
capacity ::= (T :: type, v: T'vec) => v._data.size

#{export}
size ::= (T :: type, v: T'vec) => v._size

#{export}
make ::= (T :: type) -> T'vec {
  result: T'vec
  resize(&result._data, 1)
  return result
}

#{export}
append ::= (T :: type, val: T, v: *T'vec) -> () {
  if (v._data.size == v._size) then { resize(&v._data, v._data.size * 2) }
  v._data[v._size] = val
  v._size += 1
}

#{export}
remove ::= (T :: type, v: *T'vec) -> T {
  v._size -= 1
  result := v._data[v._size]
  return result
}

#{export}
dump ::= (v: $v) -> () {
  if (v._size == 0) then { io.Print("[]") }
  io.Print("[")
  io.Print(v._data[0])
  i := 1
  while (i < v._size) do {
    io.Print(", ")
    io.Print(v._data[i])
    i += 1
  }
  io.Print("]")
}
