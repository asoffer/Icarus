// TODO: The precise types here are actually architecture dependent. We need to
// provide some platform-querying capabilities so that we don't need to, for
// example hard-code malloc's parameter to u64 when in reality it is
// `std::size_t` which may be 32-bits on some platforms.
malloc ::= foreign("malloc", u64 -> [*]u8)
free   ::= foreign("free", ([*]u8) -> ())
memset ::= foreign("memset", ([*]u8, i32, u64) -> [*]u8)
memcpy ::= foreign("memcpy", ([*]u8, [*]u8, u64) -> [*]u8)

// TODO: Improve implementation.
#{export}
string ::= struct {
  // TODO: Remove export of _data.
  #{export}
  _data:     [*]u8
  _length:   u64

  // TODO: Copy/move assignment/construction are currently incorrect.
  destroy ::= (self: *string) -> () { free(self._data) }
}

#{export}
make_string ::= (fill: u8, length: u64) -> string {
  buffer := malloc(length + 1 as u64)
  memset(buffer, fill as i32, length)
  buffer[length] = 0 as u8
  return string.{
    _data = buffer 
    _length = length
  }
}

#{export}
make_string ::= (bv: byte_view) -> string {
  buffer := malloc(bv.length + 1 as u64)
  memcpy(buffer, &bv[0], bv.length + 1 as u64)
  return string.{
    _data = buffer 
    _length = bv.length
  }
}
