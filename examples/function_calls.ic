io ::= import "examples/lib/io.ic"

// The purpose of this example is to show all the ways in which functions can
// be called. This includes things like default arguments, named arguments,
// dynamic dispatch, and and all the combinations thereof.

io.Print("Basic calls:\n")
basic_calls()
io.Print("----------------------------------------------------------------\n")

io.Print("Named arguments:\n")
named_arguments()
io.Print("----------------------------------------------------------------\n")

io.Print("Default arguments:\n")
default_arguments()
io.Print("----------------------------------------------------------------\n")

io.Print("Compile-time arguments:\n")
compile_time_arguments()
io.Print("----------------------------------------------------------------\n")

io.Print("Dynamic dispatch:\n")
dynamic_dispatch()
io.Print("----------------------------------------------------------------\n")

io.Print("Multiple return values:\n")
multiple_return_values()
io.Print("----------------------------------------------------------------\n")

// ============================================================================

basic_calls ::= () -> () {
  // There are several syntaxes for defining functions. The most verbose uses
  // the single arrow `->`.
  squared ::= (n: int64) -> int64 { return n * n }

  // The shortest option is to use the double arrow `=>`. Using this syntax, the
  // return type is inferred, and the returned value is placed on the right-hand
  // side of the arrow. As with the previous example, because the return type is
  // inferred, the function must not be recursive.
  cubed ::= (n: int64) -> int64 { return n * n * n }//=> n * n * n

  // This means that the short option is not particularly useful for functions
  // that are more than a single expression. However, we also allow the return
  // type to be inferred for longer functions by simply not specifying the
  // return type:
  print_sum ::= (x: int64, y: int64) -> int64 {
    io.Print("x + y = ")
    io.Print(x + y)
    io.Print("\n")
  }

  // Functions can be called by passing arguments in parentheses after the name
  // of the function.
  io.Print("2^2 = ")
  io.Print(squared(2))
  io.Print("\n")
  print_sum(3, 4)

  // Functions may also be called by following the arguments with a single quote
  // character ' and then the function name.
  io.Print("2^3 = ")
  io.Print(2'cubed)
  io.Print("\n")
  (3, 4)'print_sum
  io.Print("2^3^3 = ")
  io.Print(2'cubed'cubed)
  io.Print("\n")

  // There is nothing special here about giving functions a name. Function
  // literals (often referred to as "lambdas") can be called in exactly the same
  // way.
  io.Print("3^2 = ")
  // TODO io.Print(((n: int64) => n * n)(3))
  io.Print("\n")
  io.Print("4^2 = ")
  // TODO io.Print(4'((n: int64) => n * n))
  io.Print("\n")
}

named_arguments ::= () -> () {
  // Functions which are compile-time constants can have their arguments called
  // with names. You may specify the names in any order, but once a named
  // argument is used, all further arguments must also be named.
  f ::= (a: int64, b: int64, c: int64, d: int64, e: int64) -> () {
    io.Print("f(a = ")
    io.Print(a)
    io.Print(", ")
    io.Print("b = ")
    io.Print(b)
    io.Print(", ")
    io.Print("c = ")
    io.Print(c)
    io.Print(", ")
    io.Print("d = ")
    io.Print(d)
    io.Print(", ")
    io.Print("e = ")
    io.Print(e)
    io.Print(")\n")
  }

  // A call to f using only positional arguments:
  f(1, 2, 3, 4, 5)

  // A call to f using only named arguments:
  f(e = 5, d = 4, c = 3, b = 2, a = 1)

  // A call to f with a mix of named and positional arguments:
  f(1, 2, 3, d = 4, e = 5)

  // Once again, there is nothing special about the fact that we gave a name to
  // the function f. We colud just as well have called a lambda:
  // TODO (x: int64, y: int64) -> () {
  //   io.Print("lambda called with x = ")
  //   io.Print(x)
  //   io.Print(" and y = ")
  //   io.Print(y)
  //   io.Print("\n")
  // }(y = 3, x = 4)

  // However, to use named arguments, a function must be known at compile-time.
  // If a function is not a compile-time constant, as below (note the use of :=
  // instead of ::=), attempting to use a named argument will result in a
  // compilation error. This is because the function could be reassigned while
  // the program is running to a new value with different names for its
  // arguments.
  // TODO g := (n: int64) => n * n
  // Uncomment the following line to get a compilation error:
  // io.Print(g(n = 3))
}

default_arguments ::= () -> () {
  // Functions can also take default arguments. Default arguments are specified
  // at the function definition cite. The normal declaration rules apply. Here
  // we are specifying that the argument `b` gets a default value of 2 if no
  // value is provided. We can also infer the type of the argument as is done
  // with `c := 3`.
  // 5`.
  f ::= (a: int64, b: int64 = 2, c := 3) -> () {
    io.Print("f(a = ")
    io.Print(a)
    io.Print(", b = ")
    io.Print(b)
    io.Print(", c = ")
    io.Print(c)
    io.Print(")\n")
  }
  f(1)
  f(1, 20)
  f(1, 20, 30)

  // This works with named arguments too:
  f(c = 30, a = 10)

  // If a function call uses a default argument, further arguments must either
  // use the default if they have one, or be named. In the example below, only
  // `b` has a default, so if a value for `b` is not provided at the call site,
  // `c` must be explicitly named.
  g ::= (a: int64, b := 2, c: int64) -> () {
    io.Print("g(a = ")
    io.Print(a)
    io.Print(", b = ")
    io.Print(b)
    io.Print(", c = ")
    io.Print(c)
    io.Print(")\n")
  }
  g(10, 20, 30)
  g(10, c = 30)
  g(c = 30, a = 10)
  // Uncomment the following line to get a compilation error:
  // g(10, 30)
}
 
compile_time_arguments ::= () -> () {
  // So far we have only seen arguments to functions declared with a
  // single colon. Using `::` marks the argument as required to be known at
  // compile-time.
//   compile_time_square ::= (n :: int64) => n * n
//   io.Print(compile_time_square(3))
//   io.Print("\n")
// 
//   // Compile-time arguments do not need to be literals. They can also be
//   // compile-time constants, or expressions known at compile-time.
//   N ::= 17
//   io.Print(compile_time_square(N))
//   io.Print("\n")
//   io.Print(compile_time_square(2 * N - 10))
//   io.Print("\n")
// 
//   // Compile-time arguments work just as well with named or default arguments.
//   f ::= (a: int64, b ::= 2, c: int64) -> () {
//     io.Print("f(a = ")
//     io.Print(a)
//     io.Print(", b = ")
//     io.Print(b)
//     io.Print(", c = ")
//     io.Print(c)
//     io.Print(")\n")
//   }
//   f(1, c = 3)
//   f(1, c = 30, b = 20)
// 
//   // One benefit of compile-time arguments is that they can be used in the
//   // return type of a function.
//   // default_int_array ::= (len :: int64) -> [len; int64] {
//   //   result: [len; int64]
//   //   return result
//   // }
//   // TODO print default_int_array(3)
}
 
dynamic_dispatch ::= () -> () {
  // The idea behind dynamic dispatch is the ability to call a function without
  // knowing at run-time exactly which function will be called. Icarus supports
  // dynamic dispatch with a variant type. If a variant is passed to a function,
  // a function of the given name need not actually exist, so long as the
  // function exists for any possible input type. For example,
  f ::= (n: int64) -> () { io.Print("f(int64)\n") }
  f ::= (x: bool | float32) -> () { io.Print("f(bool | float32)\n") }
  v: bool | int64 = true
  f(v) // Calls the (bool | float32) overload.

  v = 3
  f(v) // Calls the int64 overload.

  // Note that in the above, there is no function named f that takes a value of
  // type bool | int64. Moreover, there is not even a function for each member of
  // the variant. However, the int64 overload of `f` and the `bool | float32`
  // overload of `f` together cover all possibilities for `v`, which enables the
  // compiler to add code which picks the correct overload to be called at
  // run-time.

  // Dynamic dispatch can be used simultaneously with multiple arguments.
  g ::= (x: bool, y: bool) -> () { io.Print("g(x: bool, y: bool)\n") }
  g ::= (x: bool, y: int64) -> () { io.Print("g(x: bool, y: int64)\n") }
  g ::= (x: int64, y: int64) -> () { io.Print("g(x: int64, y: int64)\n") }
  g ::= (x: int64, y: bool) -> () { io.Print("g(x: int64, y: bool)\n") }
  g(v, v)

  // This works just as well with named arguments
  // TODO g(y = v, x = true)

  // And even with default arguments.
  h ::= (x: bool = true, y: int64) -> () { io.Print("h(x: bool, y: int64)\n") }
  h ::= (x: int64, y: int64) -> () { io.Print("h(x: int64, y: int64)\n") }
  h(v, 3)
  h(y = 3)

  // The functions used in a dynamic dispatch need not have the same return
  // type. The type of the result of a dynamic dispatch call will be a variant
  // of all possible return types.
  // TODO squared ::= (n: int64) => n * n
  // TODO squared ::= (r: float64) => r * r
  // TODO number: int64 | float64 = 17
  // TODO io.Print("17^2 = ")
  // TODO io.Print(number'squared)
  // TODO io.Print("\n")
  // TODO number = 1.7
  // TODO io.Print("1.7^2 = ")
  // TODO io.Print(number'squared)
  // TODO io.Print("\n")
}

multiple_return_values ::= () -> () {
// TODO
//   // Functions can have multiple return values
//   f ::= (n: int64) => (n, n * n)
// 
//   a: int64
//   b: int64
//   (a, b) = f(3)
//   io.Print(a)
//   io.Print("^2 = ")
//   io.Print(b)
//   io.Print("\n")
// 
//   // In the future, we aim to support multi-declarations, as in
//   //    (c, d) ::= f(3)
//   // But today this is not available.
// 
//   // Regarding dynamic dispatch, all possible dispatches must have the same
//   // number of arguments. When considering the resulting type of each argument,
//   // each return value position is handled separately.
//   g ::= (x: int64) => (1, 1.5)
//   g ::= (x: bool) => (1.5, 1)
// 
//   arg1: float64 | int64 = 0
//   arg2: float64 | int64 = 0
//   var: bool | int64 = true
//   (arg1, arg2) = g(var)
//   io.Print("arg1 = ")
//   io.Print(arg1)
//   io.Print(" and arg2 = ")
//   io.Print(arg2)
//   io.Print("\n")
// 
//   var = 3
//   (arg1, arg2) = g(var)
//   io.Print("arg1 = ")
//   io.Print(arg1)
//   io.Print(" and arg2 = ")
//   io.Print(arg2)
//   io.Print("\n")
}
