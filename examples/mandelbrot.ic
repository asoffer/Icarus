-- ::= import "core.ic"
io ::= import "io.ic"

complex ::= struct {
  real: f64
  imag: f64
}

squared_norm ::= (x: complex) -> f64 {
  return x.real * x.real + x.imag * x.imag
}

(+) ::= (x: complex, y: complex) -> complex {
  return complex.{
    real = x.real + y.real
    imag = x.imag + y.imag
  }
}

squared ::= (x: f64) -> f64 {
  return x * x
}

(*)::= (x: complex, y: complex) -> complex {
  return complex.{
    real = x.real * y.real - x.imag * y.imag
    imag = x.real * y.imag + x.imag * y.real
  }
}

(^)::= (x: complex, n: i64) -> complex {
  if (n == 0) then {
    return complex.{ real = 1.0 \\ imag = 0.0 }
  } else if (n < 0) then {
    sn := x'squared_norm
    return complex.{ real = x.real / sn \\ imag = -x.imag / sn }
  } else if (n == 1) then {
    return x
  } else if (n % 2 == 0) then {
    return (x * x) ^ (n / 2)
  } else {
    return x * (x * x) ^ (n / 2)
  }
}

mandelbrot ::= (a: complex) -> i64 {
  z := a
  for (0, 30) do [iter: i64] {
    z = z ^ 2 + a
    if (z'squared_norm > 4.0) then {
      return iter + 1
    }
  }
  return 30
}

linspace_state ::= struct {
  current: f64
  step: f64
  remaining: i64
}

linspace ::= scope (linspace_state) {
  enter ::= jump [state: *linspace_state] (begin: f64, end: f64, steps: i64) {
    @state = linspace_state.{
      current = begin
      step = (end - begin) / (steps as f64)
      remaining = steps
    }
    goto state.remaining == 0, done(), do(state.current)
  }

  do ::= block {
    before ::= (x: f64) => x
    after ::= jump [state: *linspace_state] () {
      state.remaining -= 1
      state.current += state.step
      goto state.remaining == 0, done(), do(state.current)
    }
  }

  exit ::= () -> () {}
}

linspace (1.0, -1.0, 40) do [y: f64] {
  linspace (-2.0, 0.5, 80) do [x: f64] {
    n := mandelbrot(complex.{ real = x \\ imag = y})
    io.Print((62 - n) as u8 as char)
  }
  io.Print(!\n)
}
