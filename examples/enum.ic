-- ::= import "core.ic"
io ::= import "io.ic"

io.Print("Basic enums:\n")
// Enums are defined by simply listing the values without commas, one per
// line.
Suit ::= enum {
  CLUB
  DIAMOND
  HEART
  SPADE
}

// Recall that `\\` represents a line break, which yield the more concise:
Boolean ::= enum { TRUE \\ FALSE }

// Enums have no default initial value, so the following line will not
// compile.
// b: Boolean

// Accessing an enumerator is done with the enum name followed by a dot.
trump := Suit.SPADE

// When printed, enumerators show just the enumerator name.
PrintEnum(trump)
io.Print("\n")

// Enums can be compared for (in)equality
io.Print("(CLUB == DIAMOND): ")
io.Print(Suit.CLUB == Suit.DIAMOND)
io.Print("\n")

// However enumerators do not come with any particular ordering, so operators
// like (<) will not work.

io.Print("--------------------------------------------------------------------\n")

io.Print("Basic flags:\n")
// Flags are like enums but whereas enums can only hold one value at a time,
// flags can have each option set or unset.
Color ::= flags { RED \\ GREEN \\ BLUE }
io.Print("My favorite color is ")
PrintFlag(Color.RED)
io.Print("\n")

// To set more than one option, use the or-operator (|).
cyan ::= (Color.GREEN | Color.BLUE)
magenta ::= (Color.RED | Color.BLUE)
yellow ::= (Color.GREEN | Color.RED)
io.Print("Yellow is just ")
PrintFlag(yellow)
io.Print("\n")

// Flag values have a default initial value consisting of all enumerators
// unset.
black: Color
// Printing an empty enumerator shows:
io.Print("Black is ")
PrintFlag(black)
io.Print("\n")

// Flag values can also be negated:
io.Print("Cyan is ")
PrintFlag(not Color.RED)
io.Print("\n")

// Flags do come with a partial ordering where "less than" means having a
// subset of the enumerators set.
io.Print("Red is \"less than\" magenta: ")
io.Print(Color.RED < magenta)
io.Print("\n")
io.Print("However, Red and blue are not comparable:\n")
io.Print("  RED < BLUE: ")
io.Print(Color.RED < Color.BLUE)
io.Print("\n")
io.Print("  BLUE < RED: ")
io.Print(Color.BLUE < Color.RED)
io.Print("\n")

// Flags can be xor-ed together:
io.Print("Cyan is ")
PrintFlag(magenta ^ yellow)
io.Print("\n")

// Lastly, enumerators can be intersected with the and-operator (&).
io.Print("(not red and not blue) is ")
PrintFlag(not Color.RED & not Color.BLUE)
io.Print("\n")

io.Print("Magenta is ")
PrintFlag(Color.RED | Color.BLUE)
io.Print("\n")

io.Print("--------------------------------------------------------------------\n")

// Workarounds for the lack of generics at the moment.
PrintEnum ::= (x: Suit) -> () {
  io.Print(switch (x) {
    "CLUB" when Suit.CLUB
    "DIAMOND" when Suit.DIAMOND
    "HEART" when Suit.HEART
    "SPADE" when Suit.SPADE
  })
}
PrintEnum ::= (x: Boolean) -> () {
  io.Print(switch (x) {
    "TRUE" when Boolean.TRUE
    "FALSE" when Boolean.FALSE
  })
}
PrintFlag ::= (x: Color) -> () {
  sep := ""
  io.Print("Color[")
  if (Color.RED <= x) then { io.Print("RED") \\ sep = ", " }
  if (Color.GREEN <= x) then { io.Print(sep) \\ io.Print("GREEN") \\ sep = ", " }
  if (Color.BLUE <= x) then { io.Print(sep) \\ io.Print("BLUE") }
  io.Print("]")
}

